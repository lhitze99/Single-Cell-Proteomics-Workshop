---
title: "Single Cell Proteomics Workshop"
output: html_document
---

(R Packages/Workshops we can use as a guide:

-   scp Package: <https://bioconductor.org/packages/release/bioc/vignettes/scp/inst/doc/scp.html>, <https://bioconductor.org/packages/release/bioc/vignettes/scp/inst/doc/scp_data_modelling.html>
-   QuantQC Package: <https://scp.slavovlab.net/QuantQC>
-   Small overview of some other commonly used tools for single cell proteomics analysis: <https://www.mtoz-biolabs.com/data-analysis-strategies-and-toolkits-for-single-cell-proteomics.html> )

## SCP Workshop

Welcome to your first hands-on experience in single cell proteomics! We will perform some common steps or mass spectrometry-based single cell proteomics data analysis here. We will work here with a package which is used to analyze single cell proteomics data, the `scp` package. This package is part of Bioconductor. This package works with QFeatures objects, which are a type of data structure used to store and manipulate MS-based quantitative data and with SingleCellExperiment objects, which are used to store, process, vizualize and analyse single-cell data. The data structure in this package wrap QFeature objects around SingleCellExperiment objects.

(Maybe we can show the graphic of QFeatures shortly on a slide here while we explain this)

```{r message=FALSE, warning=FALSE}
# Install all required packages

if (!require("BiocManager", quietly = TRUE))
  install.packages("BiocManager")
BiocManager::install(version = "3.21")

BiocManager::install("scp") # Package with functions for manipulating, processing, and analyzing mass spectrometry-based single-cell proteomics data
BiocManager::install("impute")
BiocManager::install("sva")
BiocManager::install("scater")


```

```{r}
# Load the required libraries
library("scp")
library("ggplot2")
library("dplyr")
library("scater")

```

The mqScpData is a subset of thedata from the SCoPE2 landmark paper (Specht et al. 2021). The sample annotation also comes from them. It consists of mass spectrometry-based single-cell measurements of approximately 40,000 monocytes and embryonic kidney cells each.

The raw data contains the following information: (\@Nisha I decided to explain all of these in more detail here, as we will need them later on, and then we can refer back to them. I also find it easier to understand the data this way. We can, of course, change this if you prefer.)

-   `runCol/Raw.file`: A field in the feature data and the sample data that provides the names of MS acquisition runs or files.
-   `quantCols`: A field in the sample data that links to columns in the quantification data and that allows to link samples to MS channels.
-   `SampleType`: A field in the sample data that provides the type of sample that is acquired (e.g. carrier, reference, single-cell,â€¦).
-   `Potential.contaminant`: A field in the feature data that marks contaminant peptides.
-   `Reverse`: A field in the feature data that marks reverse peptides.
-   `PIF`: A field in the feature data that provides spectral purity.
-   `PEP` or `dart_PEP`: A field in the feature data that provides peptide posterior error probabilities.
-   `Modified.sequence`: A field in the feature data that provides the peptide identifiers.
-   `Leading.razor.protein`: A field in the feature data that provides the protein identifiers.
-   At least one field in the feature data that contains quantification values. In this case, there are 16 quantification columns named as `Reporter.intensity.` followed by an index (1 to 16).

```{r}
# Typical example of what you would get after reading in a CSV file
data("mqScpData")

# Example of a sample annotation table 
data("sampleAnnotation")

# Format the tables into a QFeatures object
scp <- readSCP(assayData = mqScpData, # the dataset holding the quantitative assay
        colData = sampleAnnotation, # the dataset containing sample/column annotations
        runCol = "Raw.file", # the column of assayData and colData that contains the runs/batches
        removeEmptyCols = TRUE) # quantitative columns that contain only missing values are removed
```

See here that the 3 first assays (PSM data) contain 11 columns that correspond to the TMT-11 labels and the last assay (Peptide data) contains 16 columns that correspond to the TMT-16 labels:

```{r}
scp
```

Another way to get an overview of the scp object is to plot the object. This createse a graph where:

-    each node is an assay
-   edges are links between assays

```{r}
plot(scp)
```

#### Clean the missing data (Replace zeros by NAs)

```{r}
scp_cleaned <- zeroIsNA(scp, i = 1:4) # For this function, it is mandatory to provide the indices of the assays to be cleaned. Since we want to clean them all, we are providing all four.
```

#### Filter for peptide to spectrum match (PSM)

A PSM is the match between a measured MS/MS spectra and a specific peptide sequence that best explains it (determined by a database search software like MaxQuant).

We need to filter out low-confident PSMs.

I will continue here tomorrow

## Add why!!!!

```{r}
rowDataNames(scp_cleaned) # List available variables for each assay
```

```{r}
# Filter features based on feature annotations
scp_filtered <- filterFeatures(scp_cleaned, 
                               ~ Reverse != "+" & # Remove PSMs that are matched to the decoy database
                                 Potential.contaminant != "+" & # Remove PSMs that are matched to contaminants
                                 !is.na(PIF) & 
                                 PIF > 0.8) # Keep PSMs that exhibit a high (parental ion fraction, indicative of the purity of a spectrum) (0.8 is the usual threshold for PIF)
```

```{r}
dims(scp_filtered) # number of features and samples of all assays contained in dataset
```

We first select the assays that have sufficient PSMs (the number of rows is greater than 150), and then subset the scp object for the assays that meet the criterion.

```{r}
# Filter assays based on detected features


keepAssay <- dims(scp_filtered)[1,] > 150
scp_filtered_features <- scp_filtered[,,keepAssay]

scp_filtered_features
```

```{r}
table(colData(scp_filtered_features)[, "SampleType"])
```

```{r}
scp_scr <- computeSCR(scp_filtered_features, 
                   i = 1:3,
                   colvar = "SampleType",
                   carrierPattern = "Carrier",
                   samplePattern = "Blank|Macrophage|Monocyte",
                   sampleFUN = "mean",
                   rowDataName = "MeanSCR")
```

```{r}
rbindRowData(scp_scr, i = 1:3) |> data.frame() |>
    ggplot(aes(x = MeanSCR)) +
    geom_histogram() +
    geom_vline(xintercept = c(1/200, 0.1),
               lty = c(2, 1)) +
    scale_x_log10()
```

```{r}
scp_scr_filtered <- filterFeatures(scp_scr,
                      ~ !is.na(MeanSCR) &
                          MeanSCR < 0.1)
```

```{r}
scp_scr_filtered <- pep2qvalue(scp_scr_filtered,
                  i = 1:3,
                  PEP = "dart_PEP",
                  rowDataName = "qvalue_PSMs")
```

```{r}
scp_scr_filtered <- pep2qvalue(scp_scr_filtered,
                  i = 1:3,
                  PEP = "dart_PEP",
                  groupBy = "Leading.razor.protein",
                  rowDataName = "qvalue_proteins")
```

```{r}
scp_scr_filtered <- filterFeatures(scp_scr_filtered,
                      ~ qvalue_proteins < 0.01)
```

```{r}
scp_scr_filtered <- divideByReference(scp_scr_filtered,
                         i = 1:3,
                         colvar = "SampleType",
                         samplePattern = ".",
                         refPattern = "Reference")
```

```{r}
scp <- scp_scr_filtered
scp
```

```{r}
scp <- aggregateFeatures(scp,
                         i = 1:3,
                         fcol = "Modified.sequence",
                         name = paste0("peptides_", names(scp)),
                         fun = matrixStats::colMedians, na.rm = TRUE)
scp
plot(scp)
```

```{r}
scp <- joinAssays(scp,
                  i = 4:6,
                  name = "peptides")
plot(scp)
```

```{r}
scp <- scp[, scp$SampleType %in% c("Blank", "Macrophage", "Monocyte"), ]
scp
```

```{r}
medians <- colMedians(assay(scp[["peptides"]]), na.rm = TRUE)
scp$MedianRI <- medians
```

```{r}
colData(scp) |>
    data.frame() |>
    ggplot() +
    aes(x = MedianRI,
        y = SampleType,
        fill = SampleType) +
    geom_boxplot() +
    scale_x_log10()
```

```{r}
scp <- medianCVperCell(scp,
                       i = 1:3,
                       groupBy = "Leading.razor.protein",
                       nobs = 5,
                       norm = "div.median",
                       na.rm = TRUE,
                       colDataName = "MedianCV")
```

```{r}
getWithColData(scp, "peptides") |>
    colData() |>
    data.frame() |>
    ggplot(aes(x = MedianCV,
               fill = SampleType)) +
    geom_boxplot() +
    geom_vline(xintercept = 0.65)
```

```{r}
scp <- scp[, !is.na(scp$MedianCV) & scp$MedianCV < 0.65, ]
```

```{r}
scp <- scp[, scp$SampleType != "Blank", ]
```

```{r}
scp <- sweep(scp,
             i = "peptides",
             MARGIN = 2,
             FUN = "/",
             STATS = colMedians(assay(scp[["peptides"]]), na.rm = TRUE),
             name = "peptides_norm_col")
## Divide rows by mean
scp <- sweep(scp,
             i = "peptides_norm_col",
             MARGIN = 1,
             FUN = "/",
             STATS = rowMeans(assay(scp[["peptides_norm_col"]]),  na.rm = TRUE),
             name = "peptides_norm")
plot(scp)
```

```{r}
scp <- filterNA(scp,
                i = "peptides_norm",
                pNA = 0.99)
```

```{r}
scp <- logTransform(scp,
                    base = 2,
                    i = "peptides_norm",
                    name = "peptides_log")
```

```{r}
scp <- aggregateFeatures(scp,
                         i = "peptides_log",
                         name = "proteins",
                         fcol = "Leading.razor.protein",
                         fun = matrixStats::colMedians, na.rm = TRUE)
scp
```

```{r}
## Center columns with median
scp <- sweep(scp, i = "proteins",
             MARGIN = 2,
             FUN = "-",
             STATS = colMedians(assay(scp[["proteins"]]),
                                na.rm = TRUE),
             name = "proteins_norm_column")
## Center rows with mean
scp <- sweep(scp, i = "proteins_norm_column",
             MARGIN = 1,
             FUN = "-",
             STATS = rowMeans(assay(scp[["proteins_norm_column"]]),
                              na.rm = TRUE),
             name = "proteins_norm")
```

```{r}
scp[["proteins_norm"]] |>
    assay() |>
    is.na() |>
    mean()
```

```{r}
scp <- impute(scp,
              i = "proteins_norm",
              name = "proteins_imptd",
              method = "knn",
              k = 3, rowmax = 1, colmax= 1,
              maxp = Inf, rng.seed = 1234)
```

```{r}
scp[["proteins_imptd"]] |>
    assay() |>
    is.na() |>
    mean()
```

```{r}
sce <- getWithColData(scp, "proteins_imptd")
```

```{r}
batch <- sce$runCol
model <- model.matrix(~ SampleType, data = colData(sce))
```

```{r}
library(sva)
assay(sce) <- ComBat(dat = assay(sce),
                     batch = batch,
                     mod = model)
```

```{r}
scp <- addAssay(scp,
                y = sce,
                name = "proteins_batchC")
scp <- addAssayLinkOneToOne(scp,
                            from = "proteins_imptd",
                            to = "proteins_batchC")
```

```{r}
plot(scp)
```

```{r}
scp[["proteins_batchC"]] <- runPCA(scp[["proteins_batchC"]],
                                   ncomponents = 5,
                                   ntop = Inf,
                                   scale = TRUE,
                                   exprs_values = 1,
                                   name = "PCA")
```

```{r}
plotReducedDim(scp[["proteins_batchC"]],
               dimred = "PCA",
               colour_by = "SampleType",
               point_alpha = 1)
```

```{r}
scp[["proteins_batchC"]] <- runUMAP(scp[["proteins_batchC"]],
                                    ncomponents = 2,
                                    ntop = Inf,
                                    scale = TRUE,
                                    exprs_values = 1,
                                    n_neighbors = 3,
                                    dimred = "PCA",
                                    name = "UMAP")
```

```{r}
plotReducedDim(scp[["proteins_batchC"]],
               dimred = "UMAP",
               colour_by = "SampleType",
               point_alpha = 1)
```

```{r}
## Get the features related to Plastin-2 (P13796)
subsetByFeature(scp, "P13796") |>
    ## Format the `QFeatures` to a long format table
    longFormat(colvars = c("runCol", "SampleType", "quantCols")) |>
    data.frame() |>
    ## This is used to preserve ordering of the samples and assays in ggplot2
    mutate(assay = factor(assay, levels = names(scp)),
           Channel = sub("Reporter.intensity.", "TMT-", quantCols),
           Channel = factor(Channel, levels = unique(Channel))) |>
    ## Start plotting
    ggplot(aes(x = Channel, y = value, group = rowname, col = SampleType)) +
    geom_point() +
    ## Plot every assay in a separate facet
    facet_wrap(facets = vars(assay), scales = "free_y", ncol = 3) +
    ## Annotate plot
    xlab("Channels") +
    ylab("Intensity (arbitrary units)") +
    ## Improve plot aspect
    theme(axis.text.x = element_text(angle = 90),
          strip.text = element_text(hjust = 0),
          legend.position = "bottom")
```
